# Story 2.9: 노트 작성 중 임시 저장

## 📋 스토리 정보

- **Epic:** Epic 2 - 노트 관리 시스템
- **Story ID:** 2.9
- **Story Points:** 3
- **Priority:** P2 (Medium)
- **Status:** Ready for Review

## 👤 사용자 스토리

**As a** 노트 작성자  
**I want to** 노트 작성 중 자동으로 임시 저장되어 데이터 손실을 방지하고 싶다  
**So that** 브라우저 오류나 실수로 인한 페이지 이탈 시에도 작성 중인 내용을 복구할 수 있다

## 📝 상세 설명

사용자가 노트를 작성하는 동안 일정 시간마다 자동으로 임시 저장하여 데이터 손실을 방지합니다. 또한 사용자가 의도적으로 페이지를 떠나거나 브라우저를 닫을 때도 임시 저장된 내용을 복구할 수 있도록 합니다. 이를 통해 사용자가 안심하고 긴 노트를 작성할 수 있도록 도와줍니다.

## ✅ 수용 기준

### 기능 요구사항

1. **자동 임시 저장**
   - 노트 작성 중 3초마다 자동으로 임시 저장
   - 제목이나 본문이 변경될 때만 임시 저장 실행
   - 저장 중임을 사용자에게 시각적으로 표시
   - 저장 완료 시 상태 표시

2. **임시 저장 데이터 관리**
   - 로컬 스토리지에 임시 저장 데이터 보관
   - 사용자별로 독립적인 임시 저장 공간
   - 임시 저장 데이터는 24시간 후 자동 삭제
   - 정식 저장 시 임시 저장 데이터 자동 삭제

3. **데이터 복구 기능**
   - 페이지 새로고침 시 임시 저장된 내용 자동 복구
   - 브라우저 재시작 후에도 임시 저장된 내용 복구
   - 복구 가능한 데이터가 있을 때 사용자에게 알림
   - 복구 여부를 사용자가 선택할 수 있도록 제공

4. **사용자 경험**
   - 저장 상태를 명확하게 표시 (저장 중, 저장 완료, 저장 실패)
   - 임시 저장과 정식 저장을 구분하여 표시
   - 저장 실패 시 재시도 옵션 제공
   - 네트워크 오프라인 상태에서도 로컬 임시 저장

### 기술적 요구사항

1. **상태 관리**
   - `useAutoSave` 훅을 통한 자동 저장 로직
   - 디바운싱을 통한 과도한 저장 요청 방지
   - 저장 상태를 전역적으로 관리

2. **데이터 저장**
   - 로컬 스토리지에 JSON 형태로 저장
   - 데이터 암호화는 하지 않지만 민감한 정보는 저장하지 않음
   - 저장 실패 시 재시도 메커니즘

3. **성능 최적화**
   - 변경된 내용이 있을 때만 저장 실행
   - 저장 중에는 추가 저장 요청 차단
   - 메모리 사용량 최적화

## 🎯 사용자 시나리오

### 시나리오 1: 자동 임시 저장
1. 사용자가 노트 작성 페이지에서 제목과 본문을 입력
2. 3초 후 자동으로 "저장 중..." 상태 표시
3. 저장 완료 시 "저장됨" 상태로 변경
4. 사용자가 계속 작성하면 다시 3초 후 자동 저장

### 시나리오 2: 페이지 새로고침 후 복구
1. 사용자가 긴 노트를 작성 중 실수로 F5 키를 누름
2. 페이지가 새로고침되면서 작성 중이던 내용이 사라짐
3. 페이지 로드 시 "임시 저장된 내용이 있습니다. 복구하시겠습니까?" 알림 표시
4. 사용자가 "복구"를 선택하면 이전 내용이 자동으로 복원됨

### 시나리오 3: 브라우저 재시작 후 복구
1. 사용자가 노트를 작성 중 브라우저를 종료
2. 다음날 브라우저를 다시 열고 노트 작성 페이지 접속
3. 임시 저장된 내용이 자동으로 복구되어 표시됨
4. 사용자가 내용을 확인하고 정식 저장 또는 수정 가능

### 시나리오 4: 네트워크 오프라인 상태
1. 사용자가 노트를 작성 중 네트워크 연결이 끊어짐
2. 자동 저장이 실패하지만 로컬 스토리지에는 저장됨
3. "오프라인 상태에서 로컬에 저장됨" 메시지 표시
4. 네트워크 복구 시 자동으로 서버에 동기화

## 🔧 기술적 구현

### 1. useAutoSave 훅 구현

```typescript
// lib/hooks/useAutoSave.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import { debounce } from 'lodash';

interface AutoSaveState {
  isSaving: boolean;
  lastSaved: Date | null;
  hasUnsavedChanges: boolean;
  error: string | null;
}

interface UseAutoSaveOptions {
  saveFunction: (data: any) => Promise<void>;
  getData: () => any;
  interval?: number;
  storageKey?: string;
}

export function useAutoSave({
  saveFunction,
  getData,
  interval = 3000,
  storageKey = 'temp-note'
}: UseAutoSaveOptions) {
  const [state, setState] = useState<AutoSaveState>({
    isSaving: false,
    lastSaved: null,
    hasUnsavedChanges: false,
    error: null
  });

  const saveTimeoutRef = useRef<NodeJS.Timeout>();
  const isMountedRef = useRef(true);

  // 디바운싱된 저장 함수
  const debouncedSave = useCallback(
    debounce(async (data: any) => {
      if (!isMountedRef.current) return;

      setState(prev => ({ ...prev, isSaving: true, error: null }));

      try {
        // 로컬 스토리지에 임시 저장
        localStorage.setItem(storageKey, JSON.stringify({
          data,
          timestamp: new Date().toISOString(),
          userId: getCurrentUserId()
        }));

        // 서버에 저장 (선택적)
        await saveFunction(data);

        setState(prev => ({
          ...prev,
          isSaving: false,
          lastSaved: new Date(),
          hasUnsavedChanges: false
        }));
      } catch (error) {
        setState(prev => ({
          ...prev,
          isSaving: false,
          error: error instanceof Error ? error.message : '저장 실패'
        }));
      }
    }, interval),
    [saveFunction, storageKey, interval]
  );

  // 데이터 변경 감지 및 자동 저장
  useEffect(() => {
    const data = getData();
    if (data && (data.title || data.content)) {
      setState(prev => ({ ...prev, hasUnsavedChanges: true }));
      debouncedSave(data);
    }

    return () => {
      debouncedSave.cancel();
    };
  }, [getData, debouncedSave]);

  // 컴포넌트 언마운트 시 정리
  useEffect(() => {
    return () => {
      isMountedRef.current = false;
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, []);

  return {
    ...state,
    retrySave: () => {
      const data = getData();
      if (data) {
        debouncedSave(data);
      }
    }
  };
}
```

### 2. 임시 저장 데이터 복구 기능

```typescript
// lib/utils/tempStorage.ts
interface TempStorageData {
  data: {
    title: string;
    content: string;
  };
  timestamp: string;
  userId: string;
}

export function getTempStorageData(storageKey: string): TempStorageData | null {
  try {
    const stored = localStorage.getItem(storageKey);
    if (!stored) return null;

    const parsed: TempStorageData = JSON.parse(stored);
    
    // 24시간 이내 데이터만 유효
    const storedTime = new Date(parsed.timestamp);
    const now = new Date();
    const hoursDiff = (now.getTime() - storedTime.getTime()) / (1000 * 60 * 60);
    
    if (hoursDiff > 24) {
      localStorage.removeItem(storageKey);
      return null;
    }

    return parsed;
  } catch (error) {
    console.error('임시 저장 데이터 읽기 실패:', error);
    return null;
  }
}

export function clearTempStorageData(storageKey: string): void {
  localStorage.removeItem(storageKey);
}

export function hasTempStorageData(storageKey: string): boolean {
  return getTempStorageData(storageKey) !== null;
}
```

### 3. 노트 작성 폼에 자동 저장 적용

```typescript
// components/notes/note-form.tsx
import { useAutoSave } from '@/lib/hooks/useAutoSave';
import { SaveStatus } from '@/components/notes/save-status';

export function NoteForm({ note, onSubmit }: NoteFormProps) {
  const [formData, setFormData] = useState({
    title: note?.title || '',
    content: note?.content || ''
  });

  // 자동 저장 훅 사용
  const autoSave = useAutoSave({
    saveFunction: async (data) => {
      // 서버에 임시 저장 (선택적)
      await tempSaveNote(data);
    },
    getData: () => formData,
    interval: 3000,
    storageKey: `temp-note-${note?.id || 'new'}`
  });

  // 폼 데이터 변경 핸들러
  const handleChange = (field: string, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  // 정식 저장 시 임시 저장 데이터 삭제
  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    
    try {
      await onSubmit(formData);
      clearTempStorageData(`temp-note-${note?.id || 'new'}`);
    } catch (error) {
      console.error('노트 저장 실패:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {/* 저장 상태 표시 */}
      <SaveStatus
        isSaving={autoSave.isSaving}
        lastSaved={autoSave.lastSaved}
        hasUnsavedChanges={autoSave.hasUnsavedChanges}
        error={autoSave.error}
        onRetry={autoSave.retrySave}
      />

      {/* 폼 필드들 */}
      <div className="space-y-4">
        <div>
          <Label htmlFor="title">제목 *</Label>
          <Input
            id="title"
            value={formData.title}
            onChange={(e) => handleChange('title', e.target.value)}
            placeholder="노트 제목을 입력하세요"
            maxLength={100}
          />
        </div>

        <div>
          <Label htmlFor="content">본문</Label>
          <Textarea
            id="content"
            value={formData.content}
            onChange={(e) => handleChange('content', e.target.value)}
            placeholder="노트 본문을 입력하세요"
            maxLength={10000}
            rows={10}
          />
        </div>
      </div>

      {/* 제출 버튼들 */}
      <div className="flex justify-end space-x-3">
        <Button type="button" variant="outline" onClick={onCancel}>
          취소
        </Button>
        <Button type="submit" disabled={!formData.title.trim()}>
          {note ? '노트 수정' : '노트 생성'}
        </Button>
      </div>
    </form>
  );
}
```

### 4. 저장 상태 표시 컴포넌트

```typescript
// components/notes/save-status.tsx
interface SaveStatusProps {
  isSaving: boolean;
  lastSaved: Date | null;
  hasUnsavedChanges: boolean;
  error: string | null;
  onRetry: () => void;
}

export function SaveStatus({
  isSaving,
  lastSaved,
  hasUnsavedChanges,
  error,
  onRetry
}: SaveStatusProps) {
  if (isSaving) {
    return (
      <div className="flex items-center gap-2 text-sm text-blue-600">
        <Loader2 className="h-4 w-4 animate-spin" />
        저장 중...
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center gap-2 text-sm text-red-600">
        <AlertCircle className="h-4 w-4" />
        <span>저장 실패: {error}</span>
        <Button size="sm" variant="outline" onClick={onRetry}>
          재시도
        </Button>
      </div>
    );
  }

  if (lastSaved && !hasUnsavedChanges) {
    return (
      <div className="flex items-center gap-2 text-sm text-green-600">
        <CheckCircle className="h-4 w-4" />
        <span>저장됨 {formatDistanceToNow(lastSaved, { addSuffix: true })}</span>
      </div>
    );
  }

  if (hasUnsavedChanges) {
    return (
      <div className="flex items-center gap-2 text-sm text-orange-600">
        <Clock className="h-4 w-4" />
        <span>저장되지 않은 변경사항이 있습니다</span>
      </div>
    );
  }

  return null;
}
```

### 5. 페이지 로드 시 복구 기능

```typescript
// app/notes/new/page.tsx
import { getTempStorageData, clearTempStorageData } from '@/lib/utils/tempStorage';

export default function NewNotePage() {
  const [showRecoveryDialog, setShowRecoveryDialog] = useState(false);
  const [recoveryData, setRecoveryData] = useState(null);

  useEffect(() => {
    // 페이지 로드 시 임시 저장 데이터 확인
    const tempData = getTempStorageData('temp-note-new');
    if (tempData) {
      setRecoveryData(tempData.data);
      setShowRecoveryDialog(true);
    }
  }, []);

  const handleRecover = () => {
    // 복구 데이터를 폼에 적용
    setFormData(recoveryData);
    clearTempStorageData('temp-note-new');
    setShowRecoveryDialog(false);
  };

  const handleDiscard = () => {
    clearTempStorageData('temp-note-new');
    setShowRecoveryDialog(false);
  };

  return (
    <>
      <NoteForm
        note={null}
        onSubmit={handleSubmit}
        initialData={recoveryData}
      />

      {/* 복구 다이얼로그 */}
      <AlertDialog open={showRecoveryDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>임시 저장된 내용이 있습니다</AlertDialogTitle>
            <AlertDialogDescription>
              이전에 작성하던 노트가 임시 저장되어 있습니다. 복구하시겠습니까?
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <Button variant="outline" onClick={handleDiscard}>
              삭제
            </Button>
            <Button onClick={handleRecover}>
              복구
            </Button>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}
```

## 🧪 테스트 케이스

### 단위 테스트
- [ ] useAutoSave 훅의 자동 저장 로직 테스트
- [ ] 디바운싱 동작 테스트
- [ ] 임시 저장 데이터 관리 함수 테스트
- [ ] SaveStatus 컴포넌트 렌더링 테스트

### 통합 테스트
- [ ] 노트 작성 중 자동 저장 동작 테스트
- [ ] 페이지 새로고침 후 복구 기능 테스트
- [ ] 브라우저 재시작 후 복구 기능 테스트
- [ ] 네트워크 오프라인 상태에서 로컬 저장 테스트

### E2E 테스트
- [ ] 긴 노트 작성 중 자동 저장 시나리오
- [ ] 실수로 페이지 이탈 후 복구 시나리오
- [ ] 여러 탭에서 동시 작성 시 충돌 방지 테스트

## 🚫 제외사항

- 실시간 협업 편집
- 버전 관리 및 히스토리
- 클라우드 동기화
- 오프라인 모드에서의 완전한 기능

## 🔗 의존성

- Story 2.2: 노트 생성 (노트 작성 페이지 필요)
- Story 2.5: 노트 수정 (수정 페이지에서도 자동 저장 적용)
- lodash (디바운싱 기능)
- date-fns (시간 포맷팅)

## 📅 예상 일정

- **개발:** 1일
- **테스트:** 0.5일
- **총 소요시간:** 1.5일

## ✅ 완료 조건

- [ ] 3초마다 자동 임시 저장 동작
- [ ] 페이지 새로고침 후 데이터 복구 기능
- [ ] 저장 상태를 명확하게 표시
- [ ] 네트워크 오프라인 상태에서도 로컬 저장
- [ ] 24시간 후 임시 데이터 자동 삭제
- [ ] 모든 테스트 케이스 통과

## 📝 개발 노트

- 자동 저장은 사용자 경험을 크게 향상시키는 중요한 기능
- 과도한 저장 요청을 방지하기 위해 디바운싱 필수
- 로컬 스토리지 용량 제한을 고려한 데이터 관리 필요
- 사용자에게 저장 상태를 명확하게 알려주는 것이 중요
- 복구 기능은 사용자가 실수로 데이터를 잃지 않도록 도와줌
- 향후 실시간 협업 기능과의 충돌을 고려한 설계 필요
